---
# Dependencies
- name: Install Python dependencies
  block:
    - name: Ensure that 'python3-pip' package is present on controlling host
      ansible.builtin.package:
        name: python3-pip
        state: present
      register: package_status
      until: package_status is success
      delay: 10
      retries: 3
      delegate_to: 127.0.0.1
      run_once: true
      when: ansible_distribution != "MacOSX"

    - name: Ensure that 'google-auth' dependency is present on controlling host
      ansible.builtin.pip:
        name: google-auth
        extra_args: --user
      delegate_to: 127.0.0.1
      become: false
      vars:
        ansible_become: false
      run_once: true

# Project info
- name: "GCP: Gather information about project"
  google.cloud.gcp_resourcemanager_project_info:
    auth_kind: "serviceaccount"
    service_account_contents: "{{ lookup('ansible.builtin.env', 'GCP_SERVICE_ACCOUNT_CONTENTS') }}"
  register: project_info
  when: gcp_project is not defined or gcp_project | length < 1

# Create (if state is present)
- block:
    # if ssh_key_content is not defined, get the user public key from the system (if exists)
    - name: "Set variable: ssh_key_content"
      ansible.builtin.set_fact:
        ssh_key_content: "{{ lookup('file', '~/.ssh/id_rsa.pub') }}"
      no_log: true  # do not display the public key
      when: ssh_key_content is not defined or
            ssh_key_content | length < 1

    - name: "Set variable: gcp_network_name"
      ansible.builtin.set_fact:
        gcp_network_name: "{{ server_network if server_network is defined and server_network | length > 0 else 'default' }}"

    - name: "GCP: Gather information about network"
      google.cloud.gcp_compute_subnetwork_info:
        auth_kind: "serviceaccount"
        service_account_contents: "{{ lookup('ansible.builtin.env', 'GCP_SERVICE_ACCOUNT_CONTENTS') }}"
        project: "{{ gcp_project | default(project_info.resources[0].projectNumber) }}"
        region: "{{ server_location[:-2] if server_location[-2:] | regex_search('-[a-z]$') else server_location }}"
        filters:
          - name = "{{ gcp_network_name }}"
      register: subnetwork_info

    - name: "GCP: Extract ip_range for network '{{ gcp_network_name }}'"
      ansible.builtin.set_fact:
        gcp_network_ip_range: "{{ subnetwork_info.resources[0].ipCidrRange }}"

    # Firewall
    - name: "GCP: Create or modify SSH firewall rule"
      google.cloud.gcp_compute_firewall:
        auth_kind: "serviceaccount"
        service_account_contents: "{{ lookup('ansible.builtin.env', 'GCP_SERVICE_ACCOUNT_CONTENTS') }}"
        project: "{{ gcp_project | default(project_info.resources[0].projectNumber) }}"
        name: "{{ patroni_cluster_name }}-public-ssh-firewall-rule"
        allowed:
          - ip_protocol: tcp
            ports:
              - "{{ ansible_ssh_port | default(22) }}"
        source_ranges:
          - "0.0.0.0/0" # Allow from any IP
        target_tags:
          - "{{ patroni_cluster_name }}" # Only VMs with this tag will be affected
        network:
          selfLink: "global/networks/{{ gcp_network_name }}"
        state: present
      when:
        - ssh_public_access | bool
        - firewall | bool

    - name: "GCP: Create or modify public firewall rule"
      google.cloud.gcp_compute_firewall:
        auth_kind: "serviceaccount"
        service_account_contents: "{{ lookup('ansible.builtin.env', 'GCP_SERVICE_ACCOUNT_CONTENTS') }}"
        project: "{{ gcp_project | default(project_info.resources[0].projectNumber) }}"
        name: "{{ patroni_cluster_name }}-public-firewall-rule"
        allowed:
          - ip_protocol: tcp
            ports:
              - "{{ haproxy_listen_port.master }}"
              - "{{ haproxy_listen_port.replicas }}"
              - "{{ haproxy_listen_port.replicas_sync }}"
              - "{{ haproxy_listen_port.replicas_async }}"
              - "{{ pgbouncer_listen_port }}"
              - "{{ postgresql_port }}"
              - "{{ netdata_port | default('19999') }}"
        source_ranges:
          - "0.0.0.0/0" # Allow from any IP
        target_tags:
          - "{{ patroni_cluster_name }}" # Only VMs with this tag will be affected
        network:
          selfLink: "global/networks/{{ gcp_network_name }}"
        state: present
      when:
        - database_public_access | bool
        - firewall | bool

    - name: "GCP: Create or modify private firewall rule"
      google.cloud.gcp_compute_firewall:
        auth_kind: "serviceaccount"
        service_account_contents: "{{ lookup('ansible.builtin.env', 'GCP_SERVICE_ACCOUNT_CONTENTS') }}"
        project: "{{ gcp_project | default(project_info.resources[0].projectNumber) }}"
        name: "{{ patroni_cluster_name }}-private-firewall-rule"
        allowed:
          - ip_protocol: tcp
            ports:
              - "{{ ansible_ssh_port | default(22) }}"
              - "{{ haproxy_listen_port.master }}"
              - "{{ haproxy_listen_port.replicas }}"
              - "{{ haproxy_listen_port.replicas_sync }}"
              - "{{ haproxy_listen_port.replicas_async }}"
              - "{{ haproxy_listen_port.stats }}"
              - "{{ pgbouncer_listen_port }}"
              - "{{ postgresql_port }}"
              - "{{ patroni_restapi_port }}"
              - "{{ netdata_port | default('19999') }}"
              - "2379" # ETCD
              - "2380" # ETCD
              - "8300" # Consul
              - "8301" # Consul
              - "8302" # Consul
              - "8500" # Consul
              - "8600" # Consul
        source_ranges:
          - "{{ gcp_network_ip_range }}"
        source_tags:
          - "{{ patroni_cluster_name }}"
        network:
          selfLink: "global/networks/{{ gcp_network_name }}"
        state: present
      when: firewall | bool

    - name: "GCP: Create or modify instance"
      google.cloud.gcp_compute_instance:
        auth_kind: "serviceaccount"
        service_account_contents: "{{ lookup('ansible.builtin.env', 'GCP_SERVICE_ACCOUNT_CONTENTS') }}"
        project: "{{ gcp_project | default(project_info.resources[0].projectNumber) }}"
        zone: "{{ server_location + '-b' if not server_location is match('.*-[a-z]$') else server_location }}"  # add "-b" if the zone is not defined
        name: "{{ server_name | lower }}{{ '%02d' % (idx + 1) }}"
        machine_type: "{{ server_type }}"
        disks:
          - device_name: "{{ server_name | lower }}{{ '%02d' % (idx + 1) }}-system"
            auto_delete: true
            boot: true
            type: "{{ volume_type | default('pd-ssd') }}"
            initialize_params:
              disk_name: "{{ server_name | lower }}{{ '%02d' % (idx + 1) }}-system"
              source_image: "{{ server_image }}"
              disk_size_gb: "{{ system_volume_size | default('40') }}"  # system disk size
          - device_name: "{{ server_name | lower }}{{ '%02d' % (idx + 1) }}-storage"
            auto_delete: true
            type: "{{ volume_type | default('pd-ssd') }}"
            initialize_params:
              disk_name: "{{ server_name | lower }}{{ '%02d' % (idx + 1) }}-storage"
              disk_size_gb: "{{ volume_size | int }}"
        network_interfaces:
          - network:
              selfLink: "global/networks/{{ gcp_network_name }}"
            access_configs:
              - name: External NAT
                type: ONE_TO_ONE_NAT
        metadata:
          ssh-keys: "root:{{ ssh_key_content }}"
        tags:
          items:
            - "{{ patroni_cluster_name }}"
        status: "{{ gcp_instance_status | default('RUNNING') }}"
        state: present
      loop: "{{ range(0, servers_count | int) | list }}"
      loop_control:
        index_var: idx
        label: "{{ server_name | lower }}{{ '%02d' % (idx + 1) }}"
      register: server_result
  when: state == 'present'

- name: Wait for host to be available via SSH
  ansible.builtin.wait_for:
    host: "{{ item.networkInterfaces[0].accessConfigs[0].natIP }}"
    port: 22
    delay: 5
    timeout: 300
  loop: "{{ server_result.results }}"
  loop_control:
    label: "{{ item.networkInterfaces[0].accessConfigs[0].natIP | default('N/A') }}"
  when:
    - server_result.results is defined
    - item.networkInterfaces is defined

# Info
- name: Show GCP instance info
  ansible.builtin.debug:
    msg:
      - "ID: {{ item.id }}"
      - "Name: {{ item.name }}"
      - "Image: {{ item.disks[0].licenses[0] | basename }}"
      - "Type: {{ item.machineType | basename }}"
      - "Volume Size: {{ volume_size }} GB"
      - "Public IP: {{ item.networkInterfaces[0].accessConfigs[0].natIP }}"
      - "Private IP: {{ item.networkInterfaces[0].networkIP }}"
  loop: "{{ server_result.results }}"
  loop_control:
    label: "{{ item.networkInterfaces[0].accessConfigs[0].natIP | default('N/A') }}"
  when:
    - server_result.results is defined
    - item.networkInterfaces is defined

# Inventory
- block:
    - name: "Inventory | Initialize ip_addresses variable"
      ansible.builtin.set_fact:
        ip_addresses: []

    - name: "Inventory | Extract IP addresses"
      ansible.builtin.set_fact:
        ip_addresses: >-
          {{ ip_addresses +
            [{'public_ip': item.networkInterfaces[0].accessConfigs[0].natIP,
              'private_ip': item.networkInterfaces[0].networkIP}]
          }}
      loop: "{{ server_result.results | selectattr('networkInterfaces', 'defined') }}"
      loop_control:
        label: "public_ip: {{ item.networkInterfaces[0].accessConfigs[0].natIP }}, private_ip: {{ item.networkInterfaces[0].networkIP }}"

    - name: "Inventory | Generate in-memory inventory"
      ansible.builtin.import_tasks: inventory.yml
  when:
    - server_result.results is defined
    - server_result.results | selectattr('networkInterfaces', 'defined')

# Delete (if state is absent)
- block:
    - name: "GCP: Delete instance"
      google.cloud.gcp_compute_instance:
        auth_kind: "serviceaccount"
        service_account_contents: "{{ lookup('ansible.builtin.env', 'GCP_SERVICE_ACCOUNT_CONTENTS') }}"
        project: "{{ gcp_project | default(project_info.resources[0].projectNumber) }}"
        zone: "{{ server_location + '-b' if not server_location is match('.*-[a-z]$') else server_location }}"  # add "-b" if the zone is not defined
        name: "{{ server_name | lower }}{{ '%02d' % (idx + 1) }}"
        state: absent
      loop: "{{ range(0, servers_count | int) | list }}"
      loop_control:
        index_var: idx
        label: "{{ server_name | lower }}{{ '%02d' % (idx + 1) }}"

    - name: "GCP: Delete SSH firewall rule"
      google.cloud.gcp_compute_firewall:
        auth_kind: "serviceaccount"
        service_account_contents: "{{ lookup('ansible.builtin.env', 'GCP_SERVICE_ACCOUNT_CONTENTS') }}"
        project: "{{ gcp_project | default(project_info.resources[0].projectNumber) }}"
        name: "{{ patroni_cluster_name }}-public-ssh-firewall-rule"
        state: absent

    - name: "GCP: Delete public firewall rule"
      google.cloud.gcp_compute_firewall:
        auth_kind: "serviceaccount"
        service_account_contents: "{{ lookup('ansible.builtin.env', 'GCP_SERVICE_ACCOUNT_CONTENTS') }}"
        project: "{{ gcp_project | default(project_info.resources[0].projectNumber) }}"
        name: "{{ patroni_cluster_name }}-public-firewall-rule"
        state: absent

    - name: "GCP: Delete private firewall rule"
      google.cloud.gcp_compute_firewall:
        auth_kind: "serviceaccount"
        service_account_contents: "{{ lookup('ansible.builtin.env', 'GCP_SERVICE_ACCOUNT_CONTENTS') }}"
        project: "{{ gcp_project | default(project_info.resources[0].projectNumber) }}"
        name: "{{ patroni_cluster_name }}-private-firewall-rule"
        state: absent
  when: state == 'absent'

...
